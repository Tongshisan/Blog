# TypeScript



## 什么是 typescript

typescript 是 javascript 的一个超集, 主要提供了**类型系统**和**对 ES6 的支持**



## 为什么选择 Typescript

+ TypeScript 增加了代码的可读性和可维护性
+ TypeScript 非常包容
+ TypeScript 拥有非常活跃的社区



## TypeScript 的缺点

+ 有一定的学习成本, 需要理解 **接口 ( Interfaces ), 泛型 ( Generics ), 类 (Classes), 枚举 ( Enum )** 等概念
+ 短期会增加开发成本, 因为要多写一些类型的定义
+ 集成到构建流程需要一定的工作量
+ 和一些库结合的不是很完美



## 安装 TypeScript

```shell
npm install -g typescript
```

编译 .ts 文件

```shell
tsc test.ts
```



## 原始数据类型

Boolean, String, Number, null, undefined, Symbol

+ let isTest: boolean = false
+ let isShow: boolean = Boolean(1)
+ let str: string = 'test'
+ let num: number = 6
+ let isUsable: void = undefined



## 任意值

```typescript
let a: string = 'test
a = 7

// 报错: Type 'number' is not assignable to type 'string'
```

```typescript
let a: any = 'test'
a = 8

// 通过编译
// a 的值可以为任意类型
```



## 联合类型

```typescript
let a: string | number = 'test'
a = 7

// 通过编译
// a 的值可以为 string 类型或 number 类型
```

**访问联合类型的属性和方法**

当 ts 不确定一个联合类型的变量到底是哪个类型时, 我们只能访问此联合类型里所以类型共有的属性和方法

```typescript
function getLength(something: string | number): number {
  return something.length
}

// 报错
// Property 'length' does not exist on type 'string | number'.
// Property 'length' does not exist on type 'number'.
```

```typescript
function getString(something: string | number): string {
  return something.toString()
}

// 编译通过
```

联合类型的变量在被赋值时, 会根据类型推断的规则推断出一个类型

```typescript
let a: string | number
a = 'test'
console.log(a.length)
a = 7
console.log(a.length)

// 报错 Property 'length' does not exist on type 'number'
// 第四行 a 被推断为 number 类型, 访问他的 length 属性会报错
```



## 对象的类型 ----- 接口 

在 TypeScript 中, 我们使用接口 ( Interfaces ) 来表示对象的类型

**什么是接口?**

在面向对象语言中, 接口是一个很重要的概念, 它是对行为的抽象, 而具体如何行动需要由 **类 (classes) ** 去 **实现 (implement)**

TypeScript 中的接口是一个非常灵活的概念, 除了可用于**对类的一部分行为进行抽象**以外, 也常用于对对象的形状进行描述

```typescript
interface IPerson {
  name: string;
  age: number;
}

let tom: IPerson = {
  name: 'tom',
  age: 25
}

// 我们首先定义一个接口 IPerson, 然后定义了一个变量 tom, 它的类型是 IPerson, 这样我们就约束了 tom 的形状必须和 IPerson 一致
```

定义的变量比接口多一些和少一些属性都是不允许的:

```typescript
interface IPerson {
  name: string;
  age: number;
}

let tom: IPerson = {
  name: 'tom'
}
// Property 'length' does not exist on type 'number'

let bob: IPerson = {
  name: 'bob',
  age: 15,
  gender: 'male'
}
// Type '{ name: string; age: number; gender: string; }' is not assignable to type 'IPerson'.
//  Object literal may only specify known properties, and 'gender' does not exist in type 'IPerson'.
```

**可选属性**

有时我们不需要完全匹配一个形状, 那么可以用可选属性

```typescript
interface IPerson {
  name: string;
  age?: number
}

let tom: IPerson = {
  name: 'tom'
}

let bob: IPerson = {
  name: 'bob',
  age: 25
}

// 可以编译通过
```

以上实现了可选属性, 但**仍然不允许添加未定义的属性**

```typescript
interface IPerson {
  name: string;
  age?: number
}

let tom: IPerson = {
  name: 'tom',
  age: 25,
  gender: 'male'
}

// error 
// Type '{ name: string; age: number; gender: string; }' is not assignable to type 'IPerson'.
//  Object literal may only specify known properties, and 'gender' does not exist in type 'IPerson'.
```



